// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: internal/plugins/proto/plugin.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	PluginService_Initialize_FullMethodName = "/plugin.PluginService/Initialize"
	PluginService_Start_FullMethodName      = "/plugin.PluginService/Start"
	PluginService_Stop_FullMethodName       = "/plugin.PluginService/Stop"
	PluginService_Info_FullMethodName       = "/plugin.PluginService/Info"
	PluginService_Health_FullMethodName     = "/plugin.PluginService/Health"
)

// PluginServiceClient is the client API for PluginService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Plugin service - core interface all plugins must implement
type PluginServiceClient interface {
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error)
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error)
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error)
}

type pluginServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPluginServiceClient(cc grpc.ClientConnInterface) PluginServiceClient {
	return &pluginServiceClient{cc}
}

func (c *pluginServiceClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitializeResponse)
	err := c.cc.Invoke(ctx, PluginService_Initialize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartResponse)
	err := c.cc.Invoke(ctx, PluginService_Start_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, PluginService_Stop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InfoResponse)
	err := c.cc.Invoke(ctx, PluginService_Info_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pluginServiceClient) Health(ctx context.Context, in *HealthRequest, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, PluginService_Health_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PluginServiceServer is the server API for PluginService service.
// All implementations must embed UnimplementedPluginServiceServer
// for forward compatibility.
//
// Plugin service - core interface all plugins must implement
type PluginServiceServer interface {
	Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error)
	Start(context.Context, *StartRequest) (*StartResponse, error)
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
	Health(context.Context, *HealthRequest) (*HealthResponse, error)
	mustEmbedUnimplementedPluginServiceServer()
}

// UnimplementedPluginServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPluginServiceServer struct{}

func (UnimplementedPluginServiceServer) Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}
func (UnimplementedPluginServiceServer) Start(context.Context, *StartRequest) (*StartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedPluginServiceServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedPluginServiceServer) Info(context.Context, *InfoRequest) (*InfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Info not implemented")
}
func (UnimplementedPluginServiceServer) Health(context.Context, *HealthRequest) (*HealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Health not implemented")
}
func (UnimplementedPluginServiceServer) mustEmbedUnimplementedPluginServiceServer() {}
func (UnimplementedPluginServiceServer) testEmbeddedByValue()                       {}

// UnsafePluginServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PluginServiceServer will
// result in compilation errors.
type UnsafePluginServiceServer interface {
	mustEmbedUnimplementedPluginServiceServer()
}

func RegisterPluginServiceServer(s grpc.ServiceRegistrar, srv PluginServiceServer) {
	// If the following call pancis, it indicates UnimplementedPluginServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PluginService_ServiceDesc, srv)
}

func _PluginService_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_Initialize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_Start_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_Info_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PluginService_Health_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PluginServiceServer).Health(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PluginService_Health_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PluginServiceServer).Health(ctx, req.(*HealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PluginService_ServiceDesc is the grpc.ServiceDesc for PluginService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PluginService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.PluginService",
	HandlerType: (*PluginServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _PluginService_Initialize_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _PluginService_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _PluginService_Stop_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _PluginService_Info_Handler,
		},
		{
			MethodName: "Health",
			Handler:    _PluginService_Health_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}

const (
	MetadataScraperService_CanHandle_FullMethodName         = "/plugin.MetadataScraperService/CanHandle"
	MetadataScraperService_ExtractMetadata_FullMethodName   = "/plugin.MetadataScraperService/ExtractMetadata"
	MetadataScraperService_GetSupportedTypes_FullMethodName = "/plugin.MetadataScraperService/GetSupportedTypes"
)

// MetadataScraperServiceClient is the client API for MetadataScraperService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Metadata scraper service for plugins that extract metadata
type MetadataScraperServiceClient interface {
	CanHandle(ctx context.Context, in *CanHandleRequest, opts ...grpc.CallOption) (*CanHandleResponse, error)
	ExtractMetadata(ctx context.Context, in *ExtractMetadataRequest, opts ...grpc.CallOption) (*ExtractMetadataResponse, error)
	GetSupportedTypes(ctx context.Context, in *GetSupportedTypesRequest, opts ...grpc.CallOption) (*GetSupportedTypesResponse, error)
}

type metadataScraperServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMetadataScraperServiceClient(cc grpc.ClientConnInterface) MetadataScraperServiceClient {
	return &metadataScraperServiceClient{cc}
}

func (c *metadataScraperServiceClient) CanHandle(ctx context.Context, in *CanHandleRequest, opts ...grpc.CallOption) (*CanHandleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CanHandleResponse)
	err := c.cc.Invoke(ctx, MetadataScraperService_CanHandle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataScraperServiceClient) ExtractMetadata(ctx context.Context, in *ExtractMetadataRequest, opts ...grpc.CallOption) (*ExtractMetadataResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtractMetadataResponse)
	err := c.cc.Invoke(ctx, MetadataScraperService_ExtractMetadata_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metadataScraperServiceClient) GetSupportedTypes(ctx context.Context, in *GetSupportedTypesRequest, opts ...grpc.CallOption) (*GetSupportedTypesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSupportedTypesResponse)
	err := c.cc.Invoke(ctx, MetadataScraperService_GetSupportedTypes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MetadataScraperServiceServer is the server API for MetadataScraperService service.
// All implementations must embed UnimplementedMetadataScraperServiceServer
// for forward compatibility.
//
// Metadata scraper service for plugins that extract metadata
type MetadataScraperServiceServer interface {
	CanHandle(context.Context, *CanHandleRequest) (*CanHandleResponse, error)
	ExtractMetadata(context.Context, *ExtractMetadataRequest) (*ExtractMetadataResponse, error)
	GetSupportedTypes(context.Context, *GetSupportedTypesRequest) (*GetSupportedTypesResponse, error)
	mustEmbedUnimplementedMetadataScraperServiceServer()
}

// UnimplementedMetadataScraperServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMetadataScraperServiceServer struct{}

func (UnimplementedMetadataScraperServiceServer) CanHandle(context.Context, *CanHandleRequest) (*CanHandleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CanHandle not implemented")
}
func (UnimplementedMetadataScraperServiceServer) ExtractMetadata(context.Context, *ExtractMetadataRequest) (*ExtractMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExtractMetadata not implemented")
}
func (UnimplementedMetadataScraperServiceServer) GetSupportedTypes(context.Context, *GetSupportedTypesRequest) (*GetSupportedTypesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSupportedTypes not implemented")
}
func (UnimplementedMetadataScraperServiceServer) mustEmbedUnimplementedMetadataScraperServiceServer() {
}
func (UnimplementedMetadataScraperServiceServer) testEmbeddedByValue() {}

// UnsafeMetadataScraperServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MetadataScraperServiceServer will
// result in compilation errors.
type UnsafeMetadataScraperServiceServer interface {
	mustEmbedUnimplementedMetadataScraperServiceServer()
}

func RegisterMetadataScraperServiceServer(s grpc.ServiceRegistrar, srv MetadataScraperServiceServer) {
	// If the following call pancis, it indicates UnimplementedMetadataScraperServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MetadataScraperService_ServiceDesc, srv)
}

func _MetadataScraperService_CanHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CanHandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataScraperServiceServer).CanHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetadataScraperService_CanHandle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataScraperServiceServer).CanHandle(ctx, req.(*CanHandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataScraperService_ExtractMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExtractMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataScraperServiceServer).ExtractMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetadataScraperService_ExtractMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataScraperServiceServer).ExtractMetadata(ctx, req.(*ExtractMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MetadataScraperService_GetSupportedTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSupportedTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MetadataScraperServiceServer).GetSupportedTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MetadataScraperService_GetSupportedTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MetadataScraperServiceServer).GetSupportedTypes(ctx, req.(*GetSupportedTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MetadataScraperService_ServiceDesc is the grpc.ServiceDesc for MetadataScraperService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MetadataScraperService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.MetadataScraperService",
	HandlerType: (*MetadataScraperServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CanHandle",
			Handler:    _MetadataScraperService_CanHandle_Handler,
		},
		{
			MethodName: "ExtractMetadata",
			Handler:    _MetadataScraperService_ExtractMetadata_Handler,
		},
		{
			MethodName: "GetSupportedTypes",
			Handler:    _MetadataScraperService_GetSupportedTypes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}

const (
	ScannerHookService_OnMediaFileScanned_FullMethodName = "/plugin.ScannerHookService/OnMediaFileScanned"
	ScannerHookService_OnScanStarted_FullMethodName      = "/plugin.ScannerHookService/OnScanStarted"
	ScannerHookService_OnScanCompleted_FullMethodName    = "/plugin.ScannerHookService/OnScanCompleted"
)

// ScannerHookServiceClient is the client API for ScannerHookService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Scanner hook service for plugins that hook into the scanner
type ScannerHookServiceClient interface {
	OnMediaFileScanned(ctx context.Context, in *OnMediaFileScannedRequest, opts ...grpc.CallOption) (*OnMediaFileScannedResponse, error)
	OnScanStarted(ctx context.Context, in *OnScanStartedRequest, opts ...grpc.CallOption) (*OnScanStartedResponse, error)
	OnScanCompleted(ctx context.Context, in *OnScanCompletedRequest, opts ...grpc.CallOption) (*OnScanCompletedResponse, error)
}

type scannerHookServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewScannerHookServiceClient(cc grpc.ClientConnInterface) ScannerHookServiceClient {
	return &scannerHookServiceClient{cc}
}

func (c *scannerHookServiceClient) OnMediaFileScanned(ctx context.Context, in *OnMediaFileScannedRequest, opts ...grpc.CallOption) (*OnMediaFileScannedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnMediaFileScannedResponse)
	err := c.cc.Invoke(ctx, ScannerHookService_OnMediaFileScanned_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scannerHookServiceClient) OnScanStarted(ctx context.Context, in *OnScanStartedRequest, opts ...grpc.CallOption) (*OnScanStartedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnScanStartedResponse)
	err := c.cc.Invoke(ctx, ScannerHookService_OnScanStarted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scannerHookServiceClient) OnScanCompleted(ctx context.Context, in *OnScanCompletedRequest, opts ...grpc.CallOption) (*OnScanCompletedResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OnScanCompletedResponse)
	err := c.cc.Invoke(ctx, ScannerHookService_OnScanCompleted_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ScannerHookServiceServer is the server API for ScannerHookService service.
// All implementations must embed UnimplementedScannerHookServiceServer
// for forward compatibility.
//
// Scanner hook service for plugins that hook into the scanner
type ScannerHookServiceServer interface {
	OnMediaFileScanned(context.Context, *OnMediaFileScannedRequest) (*OnMediaFileScannedResponse, error)
	OnScanStarted(context.Context, *OnScanStartedRequest) (*OnScanStartedResponse, error)
	OnScanCompleted(context.Context, *OnScanCompletedRequest) (*OnScanCompletedResponse, error)
	mustEmbedUnimplementedScannerHookServiceServer()
}

// UnimplementedScannerHookServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedScannerHookServiceServer struct{}

func (UnimplementedScannerHookServiceServer) OnMediaFileScanned(context.Context, *OnMediaFileScannedRequest) (*OnMediaFileScannedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnMediaFileScanned not implemented")
}
func (UnimplementedScannerHookServiceServer) OnScanStarted(context.Context, *OnScanStartedRequest) (*OnScanStartedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnScanStarted not implemented")
}
func (UnimplementedScannerHookServiceServer) OnScanCompleted(context.Context, *OnScanCompletedRequest) (*OnScanCompletedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnScanCompleted not implemented")
}
func (UnimplementedScannerHookServiceServer) mustEmbedUnimplementedScannerHookServiceServer() {}
func (UnimplementedScannerHookServiceServer) testEmbeddedByValue()                            {}

// UnsafeScannerHookServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ScannerHookServiceServer will
// result in compilation errors.
type UnsafeScannerHookServiceServer interface {
	mustEmbedUnimplementedScannerHookServiceServer()
}

func RegisterScannerHookServiceServer(s grpc.ServiceRegistrar, srv ScannerHookServiceServer) {
	// If the following call pancis, it indicates UnimplementedScannerHookServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ScannerHookService_ServiceDesc, srv)
}

func _ScannerHookService_OnMediaFileScanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnMediaFileScannedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerHookServiceServer).OnMediaFileScanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScannerHookService_OnMediaFileScanned_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerHookServiceServer).OnMediaFileScanned(ctx, req.(*OnMediaFileScannedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScannerHookService_OnScanStarted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnScanStartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerHookServiceServer).OnScanStarted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScannerHookService_OnScanStarted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerHookServiceServer).OnScanStarted(ctx, req.(*OnScanStartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ScannerHookService_OnScanCompleted_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OnScanCompletedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ScannerHookServiceServer).OnScanCompleted(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ScannerHookService_OnScanCompleted_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ScannerHookServiceServer).OnScanCompleted(ctx, req.(*OnScanCompletedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ScannerHookService_ServiceDesc is the grpc.ServiceDesc for ScannerHookService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ScannerHookService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.ScannerHookService",
	HandlerType: (*ScannerHookServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OnMediaFileScanned",
			Handler:    _ScannerHookService_OnMediaFileScanned_Handler,
		},
		{
			MethodName: "OnScanStarted",
			Handler:    _ScannerHookService_OnScanStarted_Handler,
		},
		{
			MethodName: "OnScanCompleted",
			Handler:    _ScannerHookService_OnScanCompleted_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}

const (
	DatabaseService_GetModels_FullMethodName = "/plugin.DatabaseService/GetModels"
	DatabaseService_Migrate_FullMethodName   = "/plugin.DatabaseService/Migrate"
	DatabaseService_Rollback_FullMethodName  = "/plugin.DatabaseService/Rollback"
)

// DatabaseServiceClient is the client API for DatabaseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Database service for plugins that need database access
type DatabaseServiceClient interface {
	GetModels(ctx context.Context, in *GetModelsRequest, opts ...grpc.CallOption) (*GetModelsResponse, error)
	Migrate(ctx context.Context, in *MigrateRequest, opts ...grpc.CallOption) (*MigrateResponse, error)
	Rollback(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error)
}

type databaseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDatabaseServiceClient(cc grpc.ClientConnInterface) DatabaseServiceClient {
	return &databaseServiceClient{cc}
}

func (c *databaseServiceClient) GetModels(ctx context.Context, in *GetModelsRequest, opts ...grpc.CallOption) (*GetModelsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetModelsResponse)
	err := c.cc.Invoke(ctx, DatabaseService_GetModels_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Migrate(ctx context.Context, in *MigrateRequest, opts ...grpc.CallOption) (*MigrateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrateResponse)
	err := c.cc.Invoke(ctx, DatabaseService_Migrate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *databaseServiceClient) Rollback(ctx context.Context, in *RollbackRequest, opts ...grpc.CallOption) (*RollbackResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RollbackResponse)
	err := c.cc.Invoke(ctx, DatabaseService_Rollback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DatabaseServiceServer is the server API for DatabaseService service.
// All implementations must embed UnimplementedDatabaseServiceServer
// for forward compatibility.
//
// Database service for plugins that need database access
type DatabaseServiceServer interface {
	GetModels(context.Context, *GetModelsRequest) (*GetModelsResponse, error)
	Migrate(context.Context, *MigrateRequest) (*MigrateResponse, error)
	Rollback(context.Context, *RollbackRequest) (*RollbackResponse, error)
	mustEmbedUnimplementedDatabaseServiceServer()
}

// UnimplementedDatabaseServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDatabaseServiceServer struct{}

func (UnimplementedDatabaseServiceServer) GetModels(context.Context, *GetModelsRequest) (*GetModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetModels not implemented")
}
func (UnimplementedDatabaseServiceServer) Migrate(context.Context, *MigrateRequest) (*MigrateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Migrate not implemented")
}
func (UnimplementedDatabaseServiceServer) Rollback(context.Context, *RollbackRequest) (*RollbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rollback not implemented")
}
func (UnimplementedDatabaseServiceServer) mustEmbedUnimplementedDatabaseServiceServer() {}
func (UnimplementedDatabaseServiceServer) testEmbeddedByValue()                         {}

// UnsafeDatabaseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DatabaseServiceServer will
// result in compilation errors.
type UnsafeDatabaseServiceServer interface {
	mustEmbedUnimplementedDatabaseServiceServer()
}

func RegisterDatabaseServiceServer(s grpc.ServiceRegistrar, srv DatabaseServiceServer) {
	// If the following call pancis, it indicates UnimplementedDatabaseServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DatabaseService_ServiceDesc, srv)
}

func _DatabaseService_GetModels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServiceServer).GetModels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DatabaseService_GetModels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServiceServer).GetModels(ctx, req.(*GetModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DatabaseService_Migrate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServiceServer).Migrate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DatabaseService_Migrate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServiceServer).Migrate(ctx, req.(*MigrateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DatabaseService_Rollback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DatabaseServiceServer).Rollback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DatabaseService_Rollback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DatabaseServiceServer).Rollback(ctx, req.(*RollbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DatabaseService_ServiceDesc is the grpc.ServiceDesc for DatabaseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DatabaseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.DatabaseService",
	HandlerType: (*DatabaseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetModels",
			Handler:    _DatabaseService_GetModels_Handler,
		},
		{
			MethodName: "Migrate",
			Handler:    _DatabaseService_Migrate_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _DatabaseService_Rollback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}

const (
	AdminPageService_GetAdminPages_FullMethodName  = "/plugin.AdminPageService/GetAdminPages"
	AdminPageService_RegisterRoutes_FullMethodName = "/plugin.AdminPageService/RegisterRoutes"
)

// AdminPageServiceClient is the client API for AdminPageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Admin page service for plugins that provide admin interfaces
type AdminPageServiceClient interface {
	GetAdminPages(ctx context.Context, in *GetAdminPagesRequest, opts ...grpc.CallOption) (*GetAdminPagesResponse, error)
	RegisterRoutes(ctx context.Context, in *RegisterRoutesRequest, opts ...grpc.CallOption) (*RegisterRoutesResponse, error)
}

type adminPageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdminPageServiceClient(cc grpc.ClientConnInterface) AdminPageServiceClient {
	return &adminPageServiceClient{cc}
}

func (c *adminPageServiceClient) GetAdminPages(ctx context.Context, in *GetAdminPagesRequest, opts ...grpc.CallOption) (*GetAdminPagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAdminPagesResponse)
	err := c.cc.Invoke(ctx, AdminPageService_GetAdminPages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *adminPageServiceClient) RegisterRoutes(ctx context.Context, in *RegisterRoutesRequest, opts ...grpc.CallOption) (*RegisterRoutesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterRoutesResponse)
	err := c.cc.Invoke(ctx, AdminPageService_RegisterRoutes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdminPageServiceServer is the server API for AdminPageService service.
// All implementations must embed UnimplementedAdminPageServiceServer
// for forward compatibility.
//
// Admin page service for plugins that provide admin interfaces
type AdminPageServiceServer interface {
	GetAdminPages(context.Context, *GetAdminPagesRequest) (*GetAdminPagesResponse, error)
	RegisterRoutes(context.Context, *RegisterRoutesRequest) (*RegisterRoutesResponse, error)
	mustEmbedUnimplementedAdminPageServiceServer()
}

// UnimplementedAdminPageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAdminPageServiceServer struct{}

func (UnimplementedAdminPageServiceServer) GetAdminPages(context.Context, *GetAdminPagesRequest) (*GetAdminPagesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAdminPages not implemented")
}
func (UnimplementedAdminPageServiceServer) RegisterRoutes(context.Context, *RegisterRoutesRequest) (*RegisterRoutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterRoutes not implemented")
}
func (UnimplementedAdminPageServiceServer) mustEmbedUnimplementedAdminPageServiceServer() {}
func (UnimplementedAdminPageServiceServer) testEmbeddedByValue()                          {}

// UnsafeAdminPageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdminPageServiceServer will
// result in compilation errors.
type UnsafeAdminPageServiceServer interface {
	mustEmbedUnimplementedAdminPageServiceServer()
}

func RegisterAdminPageServiceServer(s grpc.ServiceRegistrar, srv AdminPageServiceServer) {
	// If the following call pancis, it indicates UnimplementedAdminPageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&AdminPageService_ServiceDesc, srv)
}

func _AdminPageService_GetAdminPages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAdminPagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminPageServiceServer).GetAdminPages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminPageService_GetAdminPages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminPageServiceServer).GetAdminPages(ctx, req.(*GetAdminPagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AdminPageService_RegisterRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdminPageServiceServer).RegisterRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AdminPageService_RegisterRoutes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdminPageServiceServer).RegisterRoutes(ctx, req.(*RegisterRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AdminPageService_ServiceDesc is the grpc.ServiceDesc for AdminPageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AdminPageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.AdminPageService",
	HandlerType: (*AdminPageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAdminPages",
			Handler:    _AdminPageService_GetAdminPages_Handler,
		},
		{
			MethodName: "RegisterRoutes",
			Handler:    _AdminPageService_RegisterRoutes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}

const (
	APIRegistrationService_GetRegisteredRoutes_FullMethodName = "/plugin.APIRegistrationService/GetRegisteredRoutes"
)

// APIRegistrationServiceClient is the client API for APIRegistrationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// APIRegistrationService allows plugins to register their API routes with the host.
type APIRegistrationServiceClient interface {
	// GetRegisteredRoutes returns a list of API routes the plugin wishes to register.
	// The host application will typically prefix these routes, e.g., /api/plugins/<plugin-id>/<route.path>
	GetRegisteredRoutes(ctx context.Context, in *GetRegisteredRoutesRequest, opts ...grpc.CallOption) (*GetRegisteredRoutesResponse, error)
}

type aPIRegistrationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAPIRegistrationServiceClient(cc grpc.ClientConnInterface) APIRegistrationServiceClient {
	return &aPIRegistrationServiceClient{cc}
}

func (c *aPIRegistrationServiceClient) GetRegisteredRoutes(ctx context.Context, in *GetRegisteredRoutesRequest, opts ...grpc.CallOption) (*GetRegisteredRoutesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetRegisteredRoutesResponse)
	err := c.cc.Invoke(ctx, APIRegistrationService_GetRegisteredRoutes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIRegistrationServiceServer is the server API for APIRegistrationService service.
// All implementations must embed UnimplementedAPIRegistrationServiceServer
// for forward compatibility.
//
// APIRegistrationService allows plugins to register their API routes with the host.
type APIRegistrationServiceServer interface {
	// GetRegisteredRoutes returns a list of API routes the plugin wishes to register.
	// The host application will typically prefix these routes, e.g., /api/plugins/<plugin-id>/<route.path>
	GetRegisteredRoutes(context.Context, *GetRegisteredRoutesRequest) (*GetRegisteredRoutesResponse, error)
	mustEmbedUnimplementedAPIRegistrationServiceServer()
}

// UnimplementedAPIRegistrationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedAPIRegistrationServiceServer struct{}

func (UnimplementedAPIRegistrationServiceServer) GetRegisteredRoutes(context.Context, *GetRegisteredRoutesRequest) (*GetRegisteredRoutesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRegisteredRoutes not implemented")
}
func (UnimplementedAPIRegistrationServiceServer) mustEmbedUnimplementedAPIRegistrationServiceServer() {
}
func (UnimplementedAPIRegistrationServiceServer) testEmbeddedByValue() {}

// UnsafeAPIRegistrationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to APIRegistrationServiceServer will
// result in compilation errors.
type UnsafeAPIRegistrationServiceServer interface {
	mustEmbedUnimplementedAPIRegistrationServiceServer()
}

func RegisterAPIRegistrationServiceServer(s grpc.ServiceRegistrar, srv APIRegistrationServiceServer) {
	// If the following call pancis, it indicates UnimplementedAPIRegistrationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&APIRegistrationService_ServiceDesc, srv)
}

func _APIRegistrationService_GetRegisteredRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegisteredRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIRegistrationServiceServer).GetRegisteredRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: APIRegistrationService_GetRegisteredRoutes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIRegistrationServiceServer).GetRegisteredRoutes(ctx, req.(*GetRegisteredRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// APIRegistrationService_ServiceDesc is the grpc.ServiceDesc for APIRegistrationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var APIRegistrationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.APIRegistrationService",
	HandlerType: (*APIRegistrationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetRegisteredRoutes",
			Handler:    _APIRegistrationService_GetRegisteredRoutes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}

const (
	SearchService_Search_FullMethodName                = "/plugin.SearchService/Search"
	SearchService_GetSearchCapabilities_FullMethodName = "/plugin.SearchService/GetSearchCapabilities"
)

// SearchServiceClient is the client API for SearchService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SearchService allows plugins to provide search functionality
type SearchServiceClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	GetSearchCapabilities(ctx context.Context, in *GetSearchCapabilitiesRequest, opts ...grpc.CallOption) (*GetSearchCapabilitiesResponse, error)
}

type searchServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSearchServiceClient(cc grpc.ClientConnInterface) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchResponse)
	err := c.cc.Invoke(ctx, SearchService_Search_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchServiceClient) GetSearchCapabilities(ctx context.Context, in *GetSearchCapabilitiesRequest, opts ...grpc.CallOption) (*GetSearchCapabilitiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSearchCapabilitiesResponse)
	err := c.cc.Invoke(ctx, SearchService_GetSearchCapabilities_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SearchServiceServer is the server API for SearchService service.
// All implementations must embed UnimplementedSearchServiceServer
// for forward compatibility.
//
// SearchService allows plugins to provide search functionality
type SearchServiceServer interface {
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	GetSearchCapabilities(context.Context, *GetSearchCapabilitiesRequest) (*GetSearchCapabilitiesResponse, error)
	mustEmbedUnimplementedSearchServiceServer()
}

// UnimplementedSearchServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSearchServiceServer struct{}

func (UnimplementedSearchServiceServer) Search(context.Context, *SearchRequest) (*SearchResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Search not implemented")
}
func (UnimplementedSearchServiceServer) GetSearchCapabilities(context.Context, *GetSearchCapabilitiesRequest) (*GetSearchCapabilitiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSearchCapabilities not implemented")
}
func (UnimplementedSearchServiceServer) mustEmbedUnimplementedSearchServiceServer() {}
func (UnimplementedSearchServiceServer) testEmbeddedByValue()                       {}

// UnsafeSearchServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SearchServiceServer will
// result in compilation errors.
type UnsafeSearchServiceServer interface {
	mustEmbedUnimplementedSearchServiceServer()
}

func RegisterSearchServiceServer(s grpc.ServiceRegistrar, srv SearchServiceServer) {
	// If the following call pancis, it indicates UnimplementedSearchServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SearchService_ServiceDesc, srv)
}

func _SearchService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_Search_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SearchService_GetSearchCapabilities_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSearchCapabilitiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).GetSearchCapabilities(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SearchService_GetSearchCapabilities_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).GetSearchCapabilities(ctx, req.(*GetSearchCapabilitiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SearchService_ServiceDesc is the grpc.ServiceDesc for SearchService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SearchService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "plugin.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SearchService_Search_Handler,
		},
		{
			MethodName: "GetSearchCapabilities",
			Handler:    _SearchService_GetSearchCapabilities_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "internal/plugins/proto/plugin.proto",
}
